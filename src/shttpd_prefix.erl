%% -*-erlang-*-
%%==============================================================================
%% Copyright 2020 Jan Henry Nystrom <JanHenryNystrom@gmail.com>
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%% http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%==============================================================================

%%%-------------------------------------------------------------------
%%% @doc
%%%   Creating prefix trees
%%% @end
%%%
%% @author Jan Henry Nystrom <JanHenryNystrom@gmail.com>
%% @copyright (C) 2020, Jan Henry Nystrom <JanHenryNystrom@gmail.com>
%%%-------------------------------------------------------------------
-module(shttpd_prefix).
-copyright('Jan Henry Nystrom <JanHenryNystrom@gmail.com>').

%% API
-export([load/2, write/2]).

%% Generated module API
-export([lookup/2]).

%% Records
-record(bucket, {prefix, rest = [], values = []}).
-record(node, {prefix, left = nil, next = nil, right = nil, values = []}).
-record(var, {name, first = nil, next = nil, values = []}).

%% ===================================================================
%% API
%% ===================================================================

%%--------------------------------------------------------------------
%% Function:
%% @doc
%%
%% @end
%%--------------------------------------------------------------------
-spec load(atom(), [#{}]) -> ok.
%%--------------------------------------------------------------------
load(Module, Routes) ->
    Plist = [key_value(Route) || Route <- Routes],
    {ok, Module, Bin} =
        compile:forms(parse(lists:flatten(gen(Module, Plist))), [binary]),
    FileName =
        "Generated by " ++ ?MODULE_STRING ++ " " ++ atom_to_list(Module),
    {module, Module} = code:load_binary(Module, FileName, Bin),
    ok.

%%--------------------------------------------------------------------
%% Function:
%% @doc
%%
%% @end
%%--------------------------------------------------------------------
-spec write(string(), plist:plist()) -> ok.
%%--------------------------------------------------------------------
write(File, Plist) ->
    Module = list_to_atom(filename:rootname(filename:basename(File))),
    file:write_file(File, gen(Module, Plist)).

%% ===================================================================
%% Generated module API
%% ===================================================================

%%--------------------------------------------------------------------
%% Function:
%% @doc
%%
%% @end
%%--------------------------------------------------------------------
-spec lookup(_, _) -> _.
%%--------------------------------------------------------------------
lookup(Key, Tree) ->
    case lookup(Key, Tree, [], undefined) of
        {_, undefined} -> undefined;
        {Bindings, [V]} -> V#{bindings => Bindings}
    end.

%% ===================================================================
%% Internal functions.
%% ===================================================================

key_value(Route = #{module := Mod, path := Path, name := Name}) ->
    Key = lift(bstring:tokens(Path, <<"/">>), []),
    Value = #{module => Mod,
              name => Name,
              extra => maps:get(extra, Route, undefined),
              log => maps:get(log, Route, true)},
    case maps:get(methods, Route, undefined) of
        undefined -> {Key, Value};
        Methods ->
            ensure_subset(lists:sort(Methods),
                          lists:sort([M || {M, _} <-
                                               Mod:module_info(exports)])),
            {Key, Value#{methods => Methods}}
    end.

ensure_subset([], _) -> ok;
ensure_subset([H | T1], [H | T2]) -> ensure_subset(T1, T2);
ensure_subset(L = [H1 | _], [H2 | T2]) when H2 < H1 -> ensure_subset(L, T2).

lift([], Acc) -> lists:reverse(Acc);
lift([<<$:, H/binary>> | T], Acc) -> lift(T, [binary_to_atom(H, utf8) | Acc]);
lift([<<$[, $:, H/binary>>], Acc) ->
    {lists:reverse(Acc), [binary_to_atom(butlast(H, <<>>), utf8)]};
lift([<<$[, H/binary>>], Acc) ->
    {lists:reverse(Acc), [butlast(H, <<>>)]};
lift([H | T], Acc) ->
    lift(T, [H | Acc]).

butlast(<<$]>>, Acc) -> Acc;
butlast(<<H/utf8, T/binary>>, Acc) -> butlast(T, <<Acc/binary, H/utf8>>).

gen(Module, Plist) ->
    ["-module(", atom_to_list(Module), ").\n\n"
     "-export([lookup/1]).\n"
     "lookup(Key) ->\n"
     " Tree = ", io_lib:format("~w~n", [build(bucket_sort(Plist))]), ",\n"
     "    shttpd_prefix:lookup(Key, Tree).\n", 4].

bucket_sort(L) -> bucket_sort(lists:sort(L), []).

bucket_sort([], []) -> [];
bucket_sort([], [B = #bucket{rest = R} | Acc]) ->
    lists:reverse([B#bucket{rest = bucket_sort(lists:reverse(R))} | Acc]);
bucket_sort([{[H], V} | T], []) ->
    bucket_sort(T, [#bucket{prefix = H, values = [V]}]);
bucket_sort([{[H | P], V} | T], []) ->
    bucket_sort(T, [#bucket{prefix = H, rest = [{P, V}]}]);
bucket_sort([{[H], V} | T], [B = #bucket{prefix = H, values = Vs} | Acc]) ->
    bucket_sort(T, [B#bucket{values = [V | Vs]} | Acc]);
bucket_sort([{[H | P], V} | T], [B = #bucket{prefix = H, rest = T1} |Acc]) ->
    bucket_sort(T, [B#bucket{rest = [{P, V} | T1]} | Acc]);
bucket_sort([{[H], V} | T], [B = #bucket{rest = R} | Acc]) ->
    bucket_sort(T, [#bucket{prefix = H, values = [V]},
                    B#bucket{rest = bucket_sort(lists:reverse(R))} | Acc]);
bucket_sort([{[H | P], V} | T], [B = #bucket{rest = R} | Acc]) ->
    bucket_sort(T, [#bucket{prefix = H, rest = [{P, V}]},
                    B#bucket{rest = bucket_sort(lists:reverse(R))} | Acc]).

build([]) -> nil;
build([#bucket{prefix = P, rest = R, values = Vs} | T]) when is_atom(P) ->
    #var{name = P, first = build(T), next = build(R), values = Vs};
build([#bucket{prefix = P, rest = R, values = Vs}]) ->
    #node{prefix = P, next = build(R), values = Vs};
build([#bucket{prefix = P1, rest = R1, values = Vs1},
       #bucket{prefix = P2, rest = R2, values = Vs2}]) ->
    #node{prefix = P1, next = build(R1), values = Vs1,
          right = #node{prefix = P2, next = build(R2), values = Vs2}};
build(Bs) ->
    Size = length(Bs),
    {Left, #bucket{prefix = P, rest = Rest, values = Vs}, Right} =
        split(Size - 1 - ((Size - 1) div 2), Bs, []),
    #node{prefix = P,
          next = build(Rest),
          left = build(Left),
          right = build(Right),
          values = Vs}.

split(0, [H | T], Acc) -> {lists:reverse(Acc), H, T};
split(N, [H | T], Acc) -> split(N - 1, T, [H | Acc]).

lookup([P], #node{prefix = P, values = Vs}, B, Prev) -> {B, update(Vs, Prev)};
lookup([P], #var{name = Name, values = Vs}, B, Prev) ->
    {[{Name, P} | B], update(Vs, Prev)};
lookup([P | _], #node{prefix = P, next = nil, values = Vs}, B, Prev) ->
    {B, update(Vs, Prev)};
lookup([P | _], #var{name = Name, next = nil, values = Vs}, B, Prev) ->
    {[{Name, P} | B], update(Vs, Prev)};
lookup([P | T], #node{prefix = P, next = Next, values = Vs}, B, Prev) ->
    lookup(T, Next, B, update(Vs, Prev));
lookup(K = [P | _], #node{prefix = P1, left = L}, B, Prev) when P < P1 ->
    lookup(K, L, B, Prev);
lookup(K, #node{right = Right}, B, Prev) ->
    lookup(K, Right, B, Prev);
lookup(K = [P | T], #var{name = Name,first=First,next=Next,values=Vs},B,Prev) ->
    case lookup(K, First, B, undefined) of
        {_, undefined} -> lookup(T, Next, [{Name, P} | B], update(Vs, Prev));
        Result -> Result
    end;
lookup(_, nil, B, Prev) ->
    {B, Prev}.

update([], Prev) -> Prev;
update(New, _) -> New.

parse(Code) -> parse(erl_scan:tokens([], Code, 0), []).

parse({done, {eof, _}, _}, Acc) -> lists:reverse(Acc);
parse({more, C}, Acc) -> parse(erl_scan:tokens(C, eof, 0), Acc);
parse({done, {ok, Toks, Location}, Code}, Acc) ->
    {ok, Form} = erl_parse:parse_form(Toks),
    parse(erl_scan:tokens([], Code, Location), [Form | Acc]).
